// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package models

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/vektah/gqlparser"
	"github.com/vektah/gqlparser/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Link() LinkResolver
	Mutation() MutationResolver
	Organization() OrganizationResolver
	Query() QueryResolver
	Repository() RepositoryResolver
	Topic() TopicResolver
	User() UserResolver
	View() ViewResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Alert struct {
		Text func(childComplexity int) int
		Type func(childComplexity int) int
		Id   func(childComplexity int) int
	}

	Link struct {
		AvailableParentTopics func(childComplexity int, first *int, after *string, last *int, before *string) int
		CreatedAt             func(childComplexity int) int
		Id                    func(childComplexity int) int
		Loading               func(childComplexity int) int
		NewlyAdded            func(childComplexity int) int
		Organization          func(childComplexity int) int
		ParentTopics          func(childComplexity int, first *int, after *string, last *int, before *string) int
		Repository            func(childComplexity int) int
		ResourcePath          func(childComplexity int) int
		Sha1                  func(childComplexity int) int
		Title                 func(childComplexity int) int
		UpdatedAt             func(childComplexity int) int
		Url                   func(childComplexity int) int
	}

	LinkConnection struct {
		Edges    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	LinkEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Mutation struct {
		SelectRepository        func(childComplexity int, input SelectRepositoryInput) int
		UpdateLinkTopics        func(childComplexity int, input UpdateLinkTopicsInput) int
		UpdateTopic             func(childComplexity int, input UpdateTopicInput) int
		UpdateTopicParentTopics func(childComplexity int, input UpdateTopicParentTopicsInput) int
		UpsertLink              func(childComplexity int, input UpsertLinkInput) int
		UpsertTopic             func(childComplexity int, input UpsertTopicInput) int
	}

	Organization struct {
		CreatedAt         func(childComplexity int) int
		DefaultRepository func(childComplexity int) int
		Id                func(childComplexity int) int
		Login             func(childComplexity int) int
		Name              func(childComplexity int) int
		Public            func(childComplexity int) int
		ResourcePath      func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
	}

	PageInfo struct {
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
		EndCursor       func(childComplexity int) int
	}

	Query struct {
		Alerts              func(childComplexity int) int
		DefaultOrganization func(childComplexity int) int
		FakeError           func(childComplexity int) int
		Viewer              func(childComplexity int) int
		View                func(childComplexity int, currentOrganizationLogin string, currentRepositoryName *string, repositoryIds []string, viewerId *string) int
	}

	Repository struct {
		DisplayColor func(childComplexity int) int
		DisplayName  func(childComplexity int) int
		FullName     func(childComplexity int) int
		Id           func(childComplexity int) int
		IsPrivate    func(childComplexity int) int
		Name         func(childComplexity int) int
		Organization func(childComplexity int) int
		Owner        func(childComplexity int) int
		RootTopic    func(childComplexity int) int
	}

	RepositoryConnection struct {
		Edges func(childComplexity int) int
	}

	RepositoryEdge struct {
		Cursor     func(childComplexity int) int
		Node       func(childComplexity int) int
		IsSelected func(childComplexity int) int
	}

	SearchResultItemConnection struct {
		Edges func(childComplexity int) int
	}

	SearchResultItemEdge struct {
		Node func(childComplexity int) int
	}

	SelectRepositoryPayload struct {
		Repository func(childComplexity int) int
		Viewer     func(childComplexity int) int
	}

	Topic struct {
		AvailableParentTopics func(childComplexity int, first *int, after *string, last *int, before *string) int
		ChildTopics           func(childComplexity int, searchString *string, first *int, after *string, last *int, before *string) int
		CreatedAt             func(childComplexity int) int
		Description           func(childComplexity int) int
		Id                    func(childComplexity int) int
		Links                 func(childComplexity int, searchString *string, first *int, after *string, last *int, before *string) int
		Loading               func(childComplexity int) int
		Name                  func(childComplexity int) int
		NewlyAdded            func(childComplexity int) int
		Organization          func(childComplexity int) int
		ParentTopics          func(childComplexity int, first *int, after *string, last *int, before *string) int
		Repository            func(childComplexity int) int
		ResourcePath          func(childComplexity int) int
		Search                func(childComplexity int, searchString string, first *int, after *string, last *int, before *string) int
		UpdatedAt             func(childComplexity int) int
	}

	TopicConnection struct {
		Edges    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	TopicEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	UpdateLinkTopicsPayload struct {
		Link func(childComplexity int) int
	}

	UpdateTopicParentTopicsPayload struct {
		Alerts func(childComplexity int) int
		Topic  func(childComplexity int) int
	}

	UpdateTopicPayload struct {
		Alerts func(childComplexity int) int
		Topic  func(childComplexity int) int
	}

	UpsertLinkPayload struct {
		Alerts   func(childComplexity int) int
		LinkEdge func(childComplexity int) int
	}

	UpsertTopicPayload struct {
		Alerts    func(childComplexity int) int
		TopicEdge func(childComplexity int) int
	}

	User struct {
		AvatarUrl          func(childComplexity int) int
		CreatedAt          func(childComplexity int) int
		DefaultRepository  func(childComplexity int) int
		Id                 func(childComplexity int) int
		IsGuest            func(childComplexity int) int
		Name               func(childComplexity int) int
		PrimaryEmail       func(childComplexity int) int
		Repositories       func(childComplexity int, first *int, after *string, last *int, before *string) int
		SelectedRepository func(childComplexity int) int
		UpdatedAt          func(childComplexity int) int
	}

	View struct {
		Link              func(childComplexity int, id string) int
		Links             func(childComplexity int, searchString *string, first *int, after *string, last *int, before *string) int
		CurrentRepository func(childComplexity int) int
		Topic             func(childComplexity int, id string) int
		Topics            func(childComplexity int, searchString *string, first *int, after *string, last *int, before *string) int
	}
}

type LinkResolver interface {
	AvailableParentTopics(ctx context.Context, obj *LinkValue, first *int, after *string, last *int, before *string) (TopicConnection, error)
	CreatedAt(ctx context.Context, obj *LinkValue) (string, error)

	Loading(ctx context.Context, obj *LinkValue) (bool, error)

	Organization(ctx context.Context, obj *LinkValue) (Organization, error)
	ParentTopics(ctx context.Context, obj *LinkValue, first *int, after *string, last *int, before *string) (TopicConnection, error)
	Repository(ctx context.Context, obj *LinkValue) (Repository, error)
	ResourcePath(ctx context.Context, obj *LinkValue) (string, error)

	UpdatedAt(ctx context.Context, obj *LinkValue) (string, error)
}
type MutationResolver interface {
	SelectRepository(ctx context.Context, input SelectRepositoryInput) (*SelectRepositoryPayload, error)
	UpdateLinkTopics(ctx context.Context, input UpdateLinkTopicsInput) (*UpdateLinkTopicsPayload, error)
	UpdateTopic(ctx context.Context, input UpdateTopicInput) (*UpdateTopicPayload, error)
	UpdateTopicParentTopics(ctx context.Context, input UpdateTopicParentTopicsInput) (*UpdateTopicParentTopicsPayload, error)
	UpsertLink(ctx context.Context, input UpsertLinkInput) (*UpsertLinkPayload, error)
	UpsertTopic(ctx context.Context, input UpsertTopicInput) (*UpsertTopicPayload, error)
}
type OrganizationResolver interface {
	CreatedAt(ctx context.Context, obj *Organization) (string, error)
	DefaultRepository(ctx context.Context, obj *Organization) (Repository, error)

	ResourcePath(ctx context.Context, obj *Organization) (string, error)
	UpdatedAt(ctx context.Context, obj *Organization) (string, error)
}
type QueryResolver interface {
	Alerts(ctx context.Context) ([]Alert, error)
	DefaultOrganization(ctx context.Context) (Organization, error)
	FakeError(ctx context.Context) (*string, error)
	Viewer(ctx context.Context) (User, error)
	View(ctx context.Context, currentOrganizationLogin string, currentRepositoryName *string, repositoryIds []string, viewerId *string) (View, error)
}
type RepositoryResolver interface {
	DisplayName(ctx context.Context, obj *Repository) (string, error)
	FullName(ctx context.Context, obj *Repository) (string, error)

	Organization(ctx context.Context, obj *Repository) (Organization, error)
	Owner(ctx context.Context, obj *Repository) (User, error)
	RootTopic(ctx context.Context, obj *Repository) (TopicValue, error)
}
type TopicResolver interface {
	AvailableParentTopics(ctx context.Context, obj *TopicValue, first *int, after *string, last *int, before *string) (TopicConnection, error)
	ChildTopics(ctx context.Context, obj *TopicValue, searchString *string, first *int, after *string, last *int, before *string) (TopicConnection, error)
	CreatedAt(ctx context.Context, obj *TopicValue) (string, error)
	Description(ctx context.Context, obj *TopicValue) (*string, error)

	Links(ctx context.Context, obj *TopicValue, searchString *string, first *int, after *string, last *int, before *string) (LinkConnection, error)
	Loading(ctx context.Context, obj *TopicValue) (bool, error)

	Organization(ctx context.Context, obj *TopicValue) (Organization, error)
	ParentTopics(ctx context.Context, obj *TopicValue, first *int, after *string, last *int, before *string) (TopicConnection, error)
	Repository(ctx context.Context, obj *TopicValue) (Repository, error)
	ResourcePath(ctx context.Context, obj *TopicValue) (string, error)
	Search(ctx context.Context, obj *TopicValue, searchString string, first *int, after *string, last *int, before *string) (SearchResultItemConnection, error)
	UpdatedAt(ctx context.Context, obj *TopicValue) (string, error)
}
type UserResolver interface {
	AvatarURL(ctx context.Context, obj *User) (string, error)
	CreatedAt(ctx context.Context, obj *User) (string, error)
	DefaultRepository(ctx context.Context, obj *User) (*Repository, error)

	IsGuest(ctx context.Context, obj *User) (bool, error)

	Repositories(ctx context.Context, obj *User, first *int, after *string, last *int, before *string) (RepositoryConnection, error)
	SelectedRepository(ctx context.Context, obj *User) (*Repository, error)
	UpdatedAt(ctx context.Context, obj *User) (string, error)
}
type ViewResolver interface {
	Link(ctx context.Context, obj *View, id string) (*LinkValue, error)
	Links(ctx context.Context, obj *View, searchString *string, first *int, after *string, last *int, before *string) (LinkConnection, error)

	Topic(ctx context.Context, obj *View, id string) (*TopicValue, error)
	Topics(ctx context.Context, obj *View, searchString *string, first *int, after *string, last *int, before *string) (TopicConnection, error)
}

func field_Link_availableParentTopics_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["after"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["last"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["before"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg3
	return args, nil

}

func field_Link_parentTopics_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["after"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["last"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["before"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg3
	return args, nil

}

func field_Mutation_selectRepository_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 SelectRepositoryInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		arg0, err = UnmarshalSelectRepositoryInput(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil

}

func field_Mutation_updateLinkTopics_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 UpdateLinkTopicsInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		arg0, err = UnmarshalUpdateLinkTopicsInput(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil

}

func field_Mutation_updateTopic_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 UpdateTopicInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		arg0, err = UnmarshalUpdateTopicInput(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil

}

func field_Mutation_updateTopicParentTopics_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 UpdateTopicParentTopicsInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		arg0, err = UnmarshalUpdateTopicParentTopicsInput(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil

}

func field_Mutation_upsertLink_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 UpsertLinkInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		arg0, err = UnmarshalUpsertLinkInput(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil

}

func field_Mutation_upsertTopic_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 UpsertTopicInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		arg0, err = UnmarshalUpsertTopicInput(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil

}

func field_Query_view_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["currentOrganizationLogin"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["currentOrganizationLogin"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["currentRepositoryName"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["currentRepositoryName"] = arg1
	var arg2 []string
	if tmp, ok := rawArgs["repositoryIds"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg2 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg2[idx1], err = graphql.UnmarshalID(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["repositoryIds"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["viewerId"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalID(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["viewerId"] = arg3
	return args, nil

}

func field_Query___type_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Topic_availableParentTopics_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["after"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["last"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["before"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg3
	return args, nil

}

func field_Topic_childTopics_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["searchString"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["searchString"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["after"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["before"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg4 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg4
	return args, nil

}

func field_Topic_links_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["searchString"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["searchString"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["after"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["before"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg4 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg4
	return args, nil

}

func field_Topic_parentTopics_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["after"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["last"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["before"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg3
	return args, nil

}

func field_Topic_search_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["searchString"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["searchString"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["after"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["before"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg4 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg4
	return args, nil

}

func field_User_repositories_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["after"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["last"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["before"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg3
	return args, nil

}

func field_View_link_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_View_links_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["searchString"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["searchString"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["after"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["before"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg4 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg4
	return args, nil

}

func field_View_topic_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_View_topics_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["searchString"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["searchString"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["after"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["before"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg4 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg4
	return args, nil

}

func field___Type_fields_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil

}

func field___Type_enumValues_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil

}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	switch typeName + "." + field {

	case "Alert.text":
		if e.complexity.Alert.Text == nil {
			break
		}

		return e.complexity.Alert.Text(childComplexity), true

	case "Alert.type":
		if e.complexity.Alert.Type == nil {
			break
		}

		return e.complexity.Alert.Type(childComplexity), true

	case "Alert.id":
		if e.complexity.Alert.Id == nil {
			break
		}

		return e.complexity.Alert.Id(childComplexity), true

	case "Link.availableParentTopics":
		if e.complexity.Link.AvailableParentTopics == nil {
			break
		}

		args, err := field_Link_availableParentTopics_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Link.AvailableParentTopics(childComplexity, args["first"].(*int), args["after"].(*string), args["last"].(*int), args["before"].(*string)), true

	case "Link.createdAt":
		if e.complexity.Link.CreatedAt == nil {
			break
		}

		return e.complexity.Link.CreatedAt(childComplexity), true

	case "Link.id":
		if e.complexity.Link.Id == nil {
			break
		}

		return e.complexity.Link.Id(childComplexity), true

	case "Link.loading":
		if e.complexity.Link.Loading == nil {
			break
		}

		return e.complexity.Link.Loading(childComplexity), true

	case "Link.newlyAdded":
		if e.complexity.Link.NewlyAdded == nil {
			break
		}

		return e.complexity.Link.NewlyAdded(childComplexity), true

	case "Link.organization":
		if e.complexity.Link.Organization == nil {
			break
		}

		return e.complexity.Link.Organization(childComplexity), true

	case "Link.parentTopics":
		if e.complexity.Link.ParentTopics == nil {
			break
		}

		args, err := field_Link_parentTopics_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Link.ParentTopics(childComplexity, args["first"].(*int), args["after"].(*string), args["last"].(*int), args["before"].(*string)), true

	case "Link.repository":
		if e.complexity.Link.Repository == nil {
			break
		}

		return e.complexity.Link.Repository(childComplexity), true

	case "Link.resourcePath":
		if e.complexity.Link.ResourcePath == nil {
			break
		}

		return e.complexity.Link.ResourcePath(childComplexity), true

	case "Link.sha1":
		if e.complexity.Link.Sha1 == nil {
			break
		}

		return e.complexity.Link.Sha1(childComplexity), true

	case "Link.title":
		if e.complexity.Link.Title == nil {
			break
		}

		return e.complexity.Link.Title(childComplexity), true

	case "Link.updatedAt":
		if e.complexity.Link.UpdatedAt == nil {
			break
		}

		return e.complexity.Link.UpdatedAt(childComplexity), true

	case "Link.url":
		if e.complexity.Link.Url == nil {
			break
		}

		return e.complexity.Link.Url(childComplexity), true

	case "LinkConnection.edges":
		if e.complexity.LinkConnection.Edges == nil {
			break
		}

		return e.complexity.LinkConnection.Edges(childComplexity), true

	case "LinkConnection.pageInfo":
		if e.complexity.LinkConnection.PageInfo == nil {
			break
		}

		return e.complexity.LinkConnection.PageInfo(childComplexity), true

	case "LinkEdge.cursor":
		if e.complexity.LinkEdge.Cursor == nil {
			break
		}

		return e.complexity.LinkEdge.Cursor(childComplexity), true

	case "LinkEdge.node":
		if e.complexity.LinkEdge.Node == nil {
			break
		}

		return e.complexity.LinkEdge.Node(childComplexity), true

	case "Mutation.selectRepository":
		if e.complexity.Mutation.SelectRepository == nil {
			break
		}

		args, err := field_Mutation_selectRepository_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SelectRepository(childComplexity, args["input"].(SelectRepositoryInput)), true

	case "Mutation.updateLinkTopics":
		if e.complexity.Mutation.UpdateLinkTopics == nil {
			break
		}

		args, err := field_Mutation_updateLinkTopics_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateLinkTopics(childComplexity, args["input"].(UpdateLinkTopicsInput)), true

	case "Mutation.updateTopic":
		if e.complexity.Mutation.UpdateTopic == nil {
			break
		}

		args, err := field_Mutation_updateTopic_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTopic(childComplexity, args["input"].(UpdateTopicInput)), true

	case "Mutation.updateTopicParentTopics":
		if e.complexity.Mutation.UpdateTopicParentTopics == nil {
			break
		}

		args, err := field_Mutation_updateTopicParentTopics_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTopicParentTopics(childComplexity, args["input"].(UpdateTopicParentTopicsInput)), true

	case "Mutation.upsertLink":
		if e.complexity.Mutation.UpsertLink == nil {
			break
		}

		args, err := field_Mutation_upsertLink_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpsertLink(childComplexity, args["input"].(UpsertLinkInput)), true

	case "Mutation.upsertTopic":
		if e.complexity.Mutation.UpsertTopic == nil {
			break
		}

		args, err := field_Mutation_upsertTopic_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpsertTopic(childComplexity, args["input"].(UpsertTopicInput)), true

	case "Organization.createdAt":
		if e.complexity.Organization.CreatedAt == nil {
			break
		}

		return e.complexity.Organization.CreatedAt(childComplexity), true

	case "Organization.defaultRepository":
		if e.complexity.Organization.DefaultRepository == nil {
			break
		}

		return e.complexity.Organization.DefaultRepository(childComplexity), true

	case "Organization.id":
		if e.complexity.Organization.Id == nil {
			break
		}

		return e.complexity.Organization.Id(childComplexity), true

	case "Organization.login":
		if e.complexity.Organization.Login == nil {
			break
		}

		return e.complexity.Organization.Login(childComplexity), true

	case "Organization.name":
		if e.complexity.Organization.Name == nil {
			break
		}

		return e.complexity.Organization.Name(childComplexity), true

	case "Organization.public":
		if e.complexity.Organization.Public == nil {
			break
		}

		return e.complexity.Organization.Public(childComplexity), true

	case "Organization.resourcePath":
		if e.complexity.Organization.ResourcePath == nil {
			break
		}

		return e.complexity.Organization.ResourcePath(childComplexity), true

	case "Organization.updatedAt":
		if e.complexity.Organization.UpdatedAt == nil {
			break
		}

		return e.complexity.Organization.UpdatedAt(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "Query.alerts":
		if e.complexity.Query.Alerts == nil {
			break
		}

		return e.complexity.Query.Alerts(childComplexity), true

	case "Query.defaultOrganization":
		if e.complexity.Query.DefaultOrganization == nil {
			break
		}

		return e.complexity.Query.DefaultOrganization(childComplexity), true

	case "Query.fakeError":
		if e.complexity.Query.FakeError == nil {
			break
		}

		return e.complexity.Query.FakeError(childComplexity), true

	case "Query.viewer":
		if e.complexity.Query.Viewer == nil {
			break
		}

		return e.complexity.Query.Viewer(childComplexity), true

	case "Query.view":
		if e.complexity.Query.View == nil {
			break
		}

		args, err := field_Query_view_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.View(childComplexity, args["currentOrganizationLogin"].(string), args["currentRepositoryName"].(*string), args["repositoryIds"].([]string), args["viewerId"].(*string)), true

	case "Repository.displayColor":
		if e.complexity.Repository.DisplayColor == nil {
			break
		}

		return e.complexity.Repository.DisplayColor(childComplexity), true

	case "Repository.displayName":
		if e.complexity.Repository.DisplayName == nil {
			break
		}

		return e.complexity.Repository.DisplayName(childComplexity), true

	case "Repository.fullName":
		if e.complexity.Repository.FullName == nil {
			break
		}

		return e.complexity.Repository.FullName(childComplexity), true

	case "Repository.id":
		if e.complexity.Repository.Id == nil {
			break
		}

		return e.complexity.Repository.Id(childComplexity), true

	case "Repository.isPrivate":
		if e.complexity.Repository.IsPrivate == nil {
			break
		}

		return e.complexity.Repository.IsPrivate(childComplexity), true

	case "Repository.name":
		if e.complexity.Repository.Name == nil {
			break
		}

		return e.complexity.Repository.Name(childComplexity), true

	case "Repository.organization":
		if e.complexity.Repository.Organization == nil {
			break
		}

		return e.complexity.Repository.Organization(childComplexity), true

	case "Repository.owner":
		if e.complexity.Repository.Owner == nil {
			break
		}

		return e.complexity.Repository.Owner(childComplexity), true

	case "Repository.rootTopic":
		if e.complexity.Repository.RootTopic == nil {
			break
		}

		return e.complexity.Repository.RootTopic(childComplexity), true

	case "RepositoryConnection.edges":
		if e.complexity.RepositoryConnection.Edges == nil {
			break
		}

		return e.complexity.RepositoryConnection.Edges(childComplexity), true

	case "RepositoryEdge.cursor":
		if e.complexity.RepositoryEdge.Cursor == nil {
			break
		}

		return e.complexity.RepositoryEdge.Cursor(childComplexity), true

	case "RepositoryEdge.node":
		if e.complexity.RepositoryEdge.Node == nil {
			break
		}

		return e.complexity.RepositoryEdge.Node(childComplexity), true

	case "RepositoryEdge.isSelected":
		if e.complexity.RepositoryEdge.IsSelected == nil {
			break
		}

		return e.complexity.RepositoryEdge.IsSelected(childComplexity), true

	case "SearchResultItemConnection.edges":
		if e.complexity.SearchResultItemConnection.Edges == nil {
			break
		}

		return e.complexity.SearchResultItemConnection.Edges(childComplexity), true

	case "SearchResultItemEdge.node":
		if e.complexity.SearchResultItemEdge.Node == nil {
			break
		}

		return e.complexity.SearchResultItemEdge.Node(childComplexity), true

	case "SelectRepositoryPayload.repository":
		if e.complexity.SelectRepositoryPayload.Repository == nil {
			break
		}

		return e.complexity.SelectRepositoryPayload.Repository(childComplexity), true

	case "SelectRepositoryPayload.viewer":
		if e.complexity.SelectRepositoryPayload.Viewer == nil {
			break
		}

		return e.complexity.SelectRepositoryPayload.Viewer(childComplexity), true

	case "Topic.availableParentTopics":
		if e.complexity.Topic.AvailableParentTopics == nil {
			break
		}

		args, err := field_Topic_availableParentTopics_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Topic.AvailableParentTopics(childComplexity, args["first"].(*int), args["after"].(*string), args["last"].(*int), args["before"].(*string)), true

	case "Topic.childTopics":
		if e.complexity.Topic.ChildTopics == nil {
			break
		}

		args, err := field_Topic_childTopics_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Topic.ChildTopics(childComplexity, args["searchString"].(*string), args["first"].(*int), args["after"].(*string), args["last"].(*int), args["before"].(*string)), true

	case "Topic.createdAt":
		if e.complexity.Topic.CreatedAt == nil {
			break
		}

		return e.complexity.Topic.CreatedAt(childComplexity), true

	case "Topic.description":
		if e.complexity.Topic.Description == nil {
			break
		}

		return e.complexity.Topic.Description(childComplexity), true

	case "Topic.id":
		if e.complexity.Topic.Id == nil {
			break
		}

		return e.complexity.Topic.Id(childComplexity), true

	case "Topic.links":
		if e.complexity.Topic.Links == nil {
			break
		}

		args, err := field_Topic_links_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Topic.Links(childComplexity, args["searchString"].(*string), args["first"].(*int), args["after"].(*string), args["last"].(*int), args["before"].(*string)), true

	case "Topic.loading":
		if e.complexity.Topic.Loading == nil {
			break
		}

		return e.complexity.Topic.Loading(childComplexity), true

	case "Topic.name":
		if e.complexity.Topic.Name == nil {
			break
		}

		return e.complexity.Topic.Name(childComplexity), true

	case "Topic.newlyAdded":
		if e.complexity.Topic.NewlyAdded == nil {
			break
		}

		return e.complexity.Topic.NewlyAdded(childComplexity), true

	case "Topic.organization":
		if e.complexity.Topic.Organization == nil {
			break
		}

		return e.complexity.Topic.Organization(childComplexity), true

	case "Topic.parentTopics":
		if e.complexity.Topic.ParentTopics == nil {
			break
		}

		args, err := field_Topic_parentTopics_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Topic.ParentTopics(childComplexity, args["first"].(*int), args["after"].(*string), args["last"].(*int), args["before"].(*string)), true

	case "Topic.repository":
		if e.complexity.Topic.Repository == nil {
			break
		}

		return e.complexity.Topic.Repository(childComplexity), true

	case "Topic.resourcePath":
		if e.complexity.Topic.ResourcePath == nil {
			break
		}

		return e.complexity.Topic.ResourcePath(childComplexity), true

	case "Topic.search":
		if e.complexity.Topic.Search == nil {
			break
		}

		args, err := field_Topic_search_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Topic.Search(childComplexity, args["searchString"].(string), args["first"].(*int), args["after"].(*string), args["last"].(*int), args["before"].(*string)), true

	case "Topic.updatedAt":
		if e.complexity.Topic.UpdatedAt == nil {
			break
		}

		return e.complexity.Topic.UpdatedAt(childComplexity), true

	case "TopicConnection.edges":
		if e.complexity.TopicConnection.Edges == nil {
			break
		}

		return e.complexity.TopicConnection.Edges(childComplexity), true

	case "TopicConnection.pageInfo":
		if e.complexity.TopicConnection.PageInfo == nil {
			break
		}

		return e.complexity.TopicConnection.PageInfo(childComplexity), true

	case "TopicEdge.cursor":
		if e.complexity.TopicEdge.Cursor == nil {
			break
		}

		return e.complexity.TopicEdge.Cursor(childComplexity), true

	case "TopicEdge.node":
		if e.complexity.TopicEdge.Node == nil {
			break
		}

		return e.complexity.TopicEdge.Node(childComplexity), true

	case "UpdateLinkTopicsPayload.link":
		if e.complexity.UpdateLinkTopicsPayload.Link == nil {
			break
		}

		return e.complexity.UpdateLinkTopicsPayload.Link(childComplexity), true

	case "UpdateTopicParentTopicsPayload.alerts":
		if e.complexity.UpdateTopicParentTopicsPayload.Alerts == nil {
			break
		}

		return e.complexity.UpdateTopicParentTopicsPayload.Alerts(childComplexity), true

	case "UpdateTopicParentTopicsPayload.topic":
		if e.complexity.UpdateTopicParentTopicsPayload.Topic == nil {
			break
		}

		return e.complexity.UpdateTopicParentTopicsPayload.Topic(childComplexity), true

	case "UpdateTopicPayload.alerts":
		if e.complexity.UpdateTopicPayload.Alerts == nil {
			break
		}

		return e.complexity.UpdateTopicPayload.Alerts(childComplexity), true

	case "UpdateTopicPayload.topic":
		if e.complexity.UpdateTopicPayload.Topic == nil {
			break
		}

		return e.complexity.UpdateTopicPayload.Topic(childComplexity), true

	case "UpsertLinkPayload.alerts":
		if e.complexity.UpsertLinkPayload.Alerts == nil {
			break
		}

		return e.complexity.UpsertLinkPayload.Alerts(childComplexity), true

	case "UpsertLinkPayload.linkEdge":
		if e.complexity.UpsertLinkPayload.LinkEdge == nil {
			break
		}

		return e.complexity.UpsertLinkPayload.LinkEdge(childComplexity), true

	case "UpsertTopicPayload.alerts":
		if e.complexity.UpsertTopicPayload.Alerts == nil {
			break
		}

		return e.complexity.UpsertTopicPayload.Alerts(childComplexity), true

	case "UpsertTopicPayload.topicEdge":
		if e.complexity.UpsertTopicPayload.TopicEdge == nil {
			break
		}

		return e.complexity.UpsertTopicPayload.TopicEdge(childComplexity), true

	case "User.avatarUrl":
		if e.complexity.User.AvatarUrl == nil {
			break
		}

		return e.complexity.User.AvatarUrl(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.defaultRepository":
		if e.complexity.User.DefaultRepository == nil {
			break
		}

		return e.complexity.User.DefaultRepository(childComplexity), true

	case "User.id":
		if e.complexity.User.Id == nil {
			break
		}

		return e.complexity.User.Id(childComplexity), true

	case "User.isGuest":
		if e.complexity.User.IsGuest == nil {
			break
		}

		return e.complexity.User.IsGuest(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.primaryEmail":
		if e.complexity.User.PrimaryEmail == nil {
			break
		}

		return e.complexity.User.PrimaryEmail(childComplexity), true

	case "User.repositories":
		if e.complexity.User.Repositories == nil {
			break
		}

		args, err := field_User_repositories_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Repositories(childComplexity, args["first"].(*int), args["after"].(*string), args["last"].(*int), args["before"].(*string)), true

	case "User.selectedRepository":
		if e.complexity.User.SelectedRepository == nil {
			break
		}

		return e.complexity.User.SelectedRepository(childComplexity), true

	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "View.link":
		if e.complexity.View.Link == nil {
			break
		}

		args, err := field_View_link_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.View.Link(childComplexity, args["id"].(string)), true

	case "View.links":
		if e.complexity.View.Links == nil {
			break
		}

		args, err := field_View_links_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.View.Links(childComplexity, args["searchString"].(*string), args["first"].(*int), args["after"].(*string), args["last"].(*int), args["before"].(*string)), true

	case "View.currentRepository":
		if e.complexity.View.CurrentRepository == nil {
			break
		}

		return e.complexity.View.CurrentRepository(childComplexity), true

	case "View.topic":
		if e.complexity.View.Topic == nil {
			break
		}

		args, err := field_View_topic_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.View.Topic(childComplexity, args["id"].(string)), true

	case "View.topics":
		if e.complexity.View.Topics == nil {
			break
		}

		args, err := field_View_topics_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.View.Topics(childComplexity, args["searchString"].(*string), args["first"].(*int), args["after"].(*string), args["last"].(*int), args["before"].(*string)), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

var alertImplementors = []string{"Alert"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Alert(ctx context.Context, sel ast.SelectionSet, obj *Alert) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, alertImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Alert")
		case "text":
			out.Values[i] = ec._Alert_text(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec._Alert_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "id":
			out.Values[i] = ec._Alert_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Alert_text(ctx context.Context, field graphql.CollectedField, obj *Alert) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Alert",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Text, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Alert_type(ctx context.Context, field graphql.CollectedField, obj *Alert) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Alert",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(AlertType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Alert_id(ctx context.Context, field graphql.CollectedField, obj *Alert) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Alert",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var linkImplementors = []string{"Link", "ResourceIdentifiable", "Namespaceable"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Link(ctx context.Context, sel ast.SelectionSet, obj *LinkValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, linkImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Link")
		case "availableParentTopics":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Link_availableParentTopics(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "createdAt":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Link_createdAt(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "id":
			out.Values[i] = ec._Link_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "loading":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Link_loading(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "newlyAdded":
			out.Values[i] = ec._Link_newlyAdded(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "organization":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Link_organization(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "parentTopics":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Link_parentTopics(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "repository":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Link_repository(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "resourcePath":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Link_resourcePath(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "sha1":
			out.Values[i] = ec._Link_sha1(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "title":
			out.Values[i] = ec._Link_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "updatedAt":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Link_updatedAt(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "url":
			out.Values[i] = ec._Link_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Link_availableParentTopics(ctx context.Context, field graphql.CollectedField, obj *LinkValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Link_availableParentTopics_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Link",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Link().AvailableParentTopics(rctx, obj, args["first"].(*int), args["after"].(*string), args["last"].(*int), args["before"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TopicConnection)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._TopicConnection(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Link_createdAt(ctx context.Context, field graphql.CollectedField, obj *LinkValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Link",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Link().CreatedAt(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Link_id(ctx context.Context, field graphql.CollectedField, obj *LinkValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Link",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _Link_loading(ctx context.Context, field graphql.CollectedField, obj *LinkValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Link",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Link().Loading(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _Link_newlyAdded(ctx context.Context, field graphql.CollectedField, obj *LinkValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Link",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewlyAdded, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _Link_organization(ctx context.Context, field graphql.CollectedField, obj *LinkValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Link",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Link().Organization(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Organization)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Organization(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Link_parentTopics(ctx context.Context, field graphql.CollectedField, obj *LinkValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Link_parentTopics_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Link",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Link().ParentTopics(rctx, obj, args["first"].(*int), args["after"].(*string), args["last"].(*int), args["before"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TopicConnection)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._TopicConnection(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Link_repository(ctx context.Context, field graphql.CollectedField, obj *LinkValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Link",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Link().Repository(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Repository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Repository(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Link_resourcePath(ctx context.Context, field graphql.CollectedField, obj *LinkValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Link",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Link().ResourcePath(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Link_sha1(ctx context.Context, field graphql.CollectedField, obj *LinkValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Link",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sha1, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Link_title(ctx context.Context, field graphql.CollectedField, obj *LinkValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Link",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Link_updatedAt(ctx context.Context, field graphql.CollectedField, obj *LinkValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Link",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Link().UpdatedAt(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Link_url(ctx context.Context, field graphql.CollectedField, obj *LinkValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Link",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var linkConnectionImplementors = []string{"LinkConnection"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _LinkConnection(ctx context.Context, sel ast.SelectionSet, obj *LinkConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, linkConnectionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LinkConnection")
		case "edges":
			out.Values[i] = ec._LinkConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._LinkConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _LinkConnection_edges(ctx context.Context, field graphql.CollectedField, obj *LinkConnection) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LinkConnection",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*LinkEdge)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._LinkEdge(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _LinkConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *LinkConnection) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LinkConnection",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(PageInfo)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._PageInfo(ctx, field.Selections, &res)
}

var linkEdgeImplementors = []string{"LinkEdge"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _LinkEdge(ctx context.Context, sel ast.SelectionSet, obj *LinkEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, linkEdgeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LinkEdge")
		case "cursor":
			out.Values[i] = ec._LinkEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "node":
			out.Values[i] = ec._LinkEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _LinkEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *LinkEdge) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LinkEdge",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _LinkEdge_node(ctx context.Context, field graphql.CollectedField, obj *LinkEdge) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "LinkEdge",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(LinkValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Link(ctx, field.Selections, &res)
}

var mutationImplementors = []string{"Mutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, mutationImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "selectRepository":
			out.Values[i] = ec._Mutation_selectRepository(ctx, field)
		case "updateLinkTopics":
			out.Values[i] = ec._Mutation_updateLinkTopics(ctx, field)
		case "updateTopic":
			out.Values[i] = ec._Mutation_updateTopic(ctx, field)
		case "updateTopicParentTopics":
			out.Values[i] = ec._Mutation_updateTopicParentTopics(ctx, field)
		case "upsertLink":
			out.Values[i] = ec._Mutation_upsertLink(ctx, field)
		case "upsertTopic":
			out.Values[i] = ec._Mutation_upsertTopic(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_selectRepository(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_selectRepository_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SelectRepository(rctx, args["input"].(SelectRepositoryInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*SelectRepositoryPayload)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._SelectRepositoryPayload(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateLinkTopics(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateLinkTopics_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateLinkTopics(rctx, args["input"].(UpdateLinkTopicsInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UpdateLinkTopicsPayload)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._UpdateLinkTopicsPayload(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateTopic(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateTopic_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateTopic(rctx, args["input"].(UpdateTopicInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UpdateTopicPayload)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._UpdateTopicPayload(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateTopicParentTopics(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateTopicParentTopics_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateTopicParentTopics(rctx, args["input"].(UpdateTopicParentTopicsInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UpdateTopicParentTopicsPayload)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._UpdateTopicParentTopicsPayload(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_upsertLink(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_upsertLink_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpsertLink(rctx, args["input"].(UpsertLinkInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UpsertLinkPayload)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._UpsertLinkPayload(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_upsertTopic(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_upsertTopic_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpsertTopic(rctx, args["input"].(UpsertTopicInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UpsertTopicPayload)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._UpsertTopicPayload(ctx, field.Selections, res)
}

var organizationImplementors = []string{"Organization", "ResourceIdentifiable"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Organization(ctx context.Context, sel ast.SelectionSet, obj *Organization) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, organizationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Organization")
		case "createdAt":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Organization_createdAt(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "defaultRepository":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Organization_defaultRepository(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "id":
			out.Values[i] = ec._Organization_id(ctx, field, obj)
		case "login":
			out.Values[i] = ec._Organization_login(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._Organization_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "public":
			out.Values[i] = ec._Organization_public(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "resourcePath":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Organization_resourcePath(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "updatedAt":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Organization_updatedAt(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Organization_createdAt(ctx context.Context, field graphql.CollectedField, obj *Organization) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Organization",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Organization().CreatedAt(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Organization_defaultRepository(ctx context.Context, field graphql.CollectedField, obj *Organization) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Organization",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Organization().DefaultRepository(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Repository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Repository(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Organization_id(ctx context.Context, field graphql.CollectedField, obj *Organization) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Organization",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _Organization_login(ctx context.Context, field graphql.CollectedField, obj *Organization) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Organization",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Login, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Organization_name(ctx context.Context, field graphql.CollectedField, obj *Organization) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Organization",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Organization_public(ctx context.Context, field graphql.CollectedField, obj *Organization) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Organization",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Public, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _Organization_resourcePath(ctx context.Context, field graphql.CollectedField, obj *Organization) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Organization",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Organization().ResourcePath(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Organization_updatedAt(ctx context.Context, field graphql.CollectedField, obj *Organization) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Organization",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Organization().UpdatedAt(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var pageInfoImplementors = []string{"PageInfo"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, pageInfoImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":
			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "hasPreviousPage":
			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "startCursor":
			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)
		case "endCursor":
			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *PageInfo) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PageInfo",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *PageInfo) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PageInfo",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *PageInfo) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PageInfo",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *PageInfo) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PageInfo",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var queryImplementors = []string{"Query"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "alerts":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_alerts(ctx, field)
				wg.Done()
			}(i, field)
		case "defaultOrganization":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_defaultOrganization(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "fakeError":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_fakeError(ctx, field)
				wg.Done()
			}(i, field)
		case "viewer":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_viewer(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "view":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_view(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Query_alerts(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Alerts(rctx)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]Alert)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Alert(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_defaultOrganization(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DefaultOrganization(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Organization)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Organization(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_fakeError(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FakeError(rctx)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_viewer(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Viewer(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._User(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_view(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_view_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().View(rctx, args["currentOrganizationLogin"].(string), args["currentRepositoryName"].(*string), args["repositoryIds"].([]string), args["viewerId"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(View)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._View(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query___type_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Schema(ctx, field.Selections, res)
}

var repositoryImplementors = []string{"Repository"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Repository(ctx context.Context, sel ast.SelectionSet, obj *Repository) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, repositoryImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Repository")
		case "displayColor":
			out.Values[i] = ec._Repository_displayColor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "displayName":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Repository_displayName(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "fullName":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Repository_fullName(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "id":
			out.Values[i] = ec._Repository_id(ctx, field, obj)
		case "isPrivate":
			out.Values[i] = ec._Repository_isPrivate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._Repository_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "organization":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Repository_organization(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "owner":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Repository_owner(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "rootTopic":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Repository_rootTopic(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Repository_displayColor(ctx context.Context, field graphql.CollectedField, obj *Repository) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Repository",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayColor(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Repository_displayName(ctx context.Context, field graphql.CollectedField, obj *Repository) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Repository",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().DisplayName(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Repository_fullName(ctx context.Context, field graphql.CollectedField, obj *Repository) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Repository",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().FullName(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Repository_id(ctx context.Context, field graphql.CollectedField, obj *Repository) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Repository",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _Repository_isPrivate(ctx context.Context, field graphql.CollectedField, obj *Repository) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Repository",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsPrivate(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _Repository_name(ctx context.Context, field graphql.CollectedField, obj *Repository) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Repository",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Repository_organization(ctx context.Context, field graphql.CollectedField, obj *Repository) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Repository",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().Organization(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Organization)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Organization(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Repository_owner(ctx context.Context, field graphql.CollectedField, obj *Repository) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Repository",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().Owner(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._User(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Repository_rootTopic(ctx context.Context, field graphql.CollectedField, obj *Repository) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Repository",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().RootTopic(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TopicValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Topic(ctx, field.Selections, &res)
}

var repositoryConnectionImplementors = []string{"RepositoryConnection"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _RepositoryConnection(ctx context.Context, sel ast.SelectionSet, obj *RepositoryConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, repositoryConnectionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepositoryConnection")
		case "edges":
			out.Values[i] = ec._RepositoryConnection_edges(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _RepositoryConnection_edges(ctx context.Context, field graphql.CollectedField, obj *RepositoryConnection) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "RepositoryConnection",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*RepositoryEdge)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._RepositoryEdge(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var repositoryEdgeImplementors = []string{"RepositoryEdge"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _RepositoryEdge(ctx context.Context, sel ast.SelectionSet, obj *RepositoryEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, repositoryEdgeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepositoryEdge")
		case "cursor":
			out.Values[i] = ec._RepositoryEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "node":
			out.Values[i] = ec._RepositoryEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isSelected":
			out.Values[i] = ec._RepositoryEdge_isSelected(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _RepositoryEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *RepositoryEdge) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "RepositoryEdge",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _RepositoryEdge_node(ctx context.Context, field graphql.CollectedField, obj *RepositoryEdge) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "RepositoryEdge",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Repository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Repository(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _RepositoryEdge_isSelected(ctx context.Context, field graphql.CollectedField, obj *RepositoryEdge) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "RepositoryEdge",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsSelected, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

var searchResultItemConnectionImplementors = []string{"SearchResultItemConnection"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SearchResultItemConnection(ctx context.Context, sel ast.SelectionSet, obj *SearchResultItemConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, searchResultItemConnectionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchResultItemConnection")
		case "edges":
			out.Values[i] = ec._SearchResultItemConnection_edges(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SearchResultItemConnection_edges(ctx context.Context, field graphql.CollectedField, obj *SearchResultItemConnection) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SearchResultItemConnection",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*SearchResultItemEdge)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._SearchResultItemEdge(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var searchResultItemEdgeImplementors = []string{"SearchResultItemEdge"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SearchResultItemEdge(ctx context.Context, sel ast.SelectionSet, obj *SearchResultItemEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, searchResultItemEdgeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchResultItemEdge")
		case "node":
			out.Values[i] = ec._SearchResultItemEdge_node(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SearchResultItemEdge_node(ctx context.Context, field graphql.CollectedField, obj *SearchResultItemEdge) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SearchResultItemEdge",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(SearchResultItem)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._SearchResultItem(ctx, field.Selections, &res)
}

var selectRepositoryPayloadImplementors = []string{"SelectRepositoryPayload"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SelectRepositoryPayload(ctx context.Context, sel ast.SelectionSet, obj *SelectRepositoryPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, selectRepositoryPayloadImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SelectRepositoryPayload")
		case "repository":
			out.Values[i] = ec._SelectRepositoryPayload_repository(ctx, field, obj)
		case "viewer":
			out.Values[i] = ec._SelectRepositoryPayload_viewer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _SelectRepositoryPayload_repository(ctx context.Context, field graphql.CollectedField, obj *SelectRepositoryPayload) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SelectRepositoryPayload",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repository, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Repository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Repository(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _SelectRepositoryPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *SelectRepositoryPayload) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "SelectRepositoryPayload",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._User(ctx, field.Selections, &res)
}

var topicImplementors = []string{"Topic", "ResourceIdentifiable", "Namespaceable"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Topic(ctx context.Context, sel ast.SelectionSet, obj *TopicValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, topicImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Topic")
		case "availableParentTopics":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Topic_availableParentTopics(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "childTopics":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Topic_childTopics(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "createdAt":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Topic_createdAt(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "description":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Topic_description(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "id":
			out.Values[i] = ec._Topic_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "links":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Topic_links(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "loading":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Topic_loading(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "name":
			out.Values[i] = ec._Topic_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "newlyAdded":
			out.Values[i] = ec._Topic_newlyAdded(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "organization":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Topic_organization(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "parentTopics":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Topic_parentTopics(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "repository":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Topic_repository(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "resourcePath":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Topic_resourcePath(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "search":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Topic_search(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "updatedAt":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Topic_updatedAt(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Topic_availableParentTopics(ctx context.Context, field graphql.CollectedField, obj *TopicValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Topic_availableParentTopics_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Topic",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Topic().AvailableParentTopics(rctx, obj, args["first"].(*int), args["after"].(*string), args["last"].(*int), args["before"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TopicConnection)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._TopicConnection(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Topic_childTopics(ctx context.Context, field graphql.CollectedField, obj *TopicValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Topic_childTopics_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Topic",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Topic().ChildTopics(rctx, obj, args["searchString"].(*string), args["first"].(*int), args["after"].(*string), args["last"].(*int), args["before"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TopicConnection)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._TopicConnection(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Topic_createdAt(ctx context.Context, field graphql.CollectedField, obj *TopicValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Topic",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Topic().CreatedAt(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Topic_description(ctx context.Context, field graphql.CollectedField, obj *TopicValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Topic",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Topic().Description(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Topic_id(ctx context.Context, field graphql.CollectedField, obj *TopicValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Topic",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _Topic_links(ctx context.Context, field graphql.CollectedField, obj *TopicValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Topic_links_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Topic",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Topic().Links(rctx, obj, args["searchString"].(*string), args["first"].(*int), args["after"].(*string), args["last"].(*int), args["before"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(LinkConnection)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._LinkConnection(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Topic_loading(ctx context.Context, field graphql.CollectedField, obj *TopicValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Topic",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Topic().Loading(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _Topic_name(ctx context.Context, field graphql.CollectedField, obj *TopicValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Topic",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Topic_newlyAdded(ctx context.Context, field graphql.CollectedField, obj *TopicValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Topic",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewlyAdded, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _Topic_organization(ctx context.Context, field graphql.CollectedField, obj *TopicValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Topic",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Topic().Organization(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Organization)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Organization(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Topic_parentTopics(ctx context.Context, field graphql.CollectedField, obj *TopicValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Topic_parentTopics_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Topic",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Topic().ParentTopics(rctx, obj, args["first"].(*int), args["after"].(*string), args["last"].(*int), args["before"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TopicConnection)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._TopicConnection(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Topic_repository(ctx context.Context, field graphql.CollectedField, obj *TopicValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Topic",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Topic().Repository(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Repository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Repository(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Topic_resourcePath(ctx context.Context, field graphql.CollectedField, obj *TopicValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Topic",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Topic().ResourcePath(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Topic_search(ctx context.Context, field graphql.CollectedField, obj *TopicValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Topic_search_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Topic",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Topic().Search(rctx, obj, args["searchString"].(string), args["first"].(*int), args["after"].(*string), args["last"].(*int), args["before"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SearchResultItemConnection)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._SearchResultItemConnection(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Topic_updatedAt(ctx context.Context, field graphql.CollectedField, obj *TopicValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Topic",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Topic().UpdatedAt(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var topicConnectionImplementors = []string{"TopicConnection"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _TopicConnection(ctx context.Context, sel ast.SelectionSet, obj *TopicConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, topicConnectionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TopicConnection")
		case "edges":
			out.Values[i] = ec._TopicConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._TopicConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _TopicConnection_edges(ctx context.Context, field graphql.CollectedField, obj *TopicConnection) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "TopicConnection",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*TopicEdge)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._TopicEdge(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _TopicConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *TopicConnection) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "TopicConnection",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(PageInfo)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._PageInfo(ctx, field.Selections, &res)
}

var topicEdgeImplementors = []string{"TopicEdge"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _TopicEdge(ctx context.Context, sel ast.SelectionSet, obj *TopicEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, topicEdgeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TopicEdge")
		case "cursor":
			out.Values[i] = ec._TopicEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "node":
			out.Values[i] = ec._TopicEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _TopicEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *TopicEdge) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "TopicEdge",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _TopicEdge_node(ctx context.Context, field graphql.CollectedField, obj *TopicEdge) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "TopicEdge",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TopicValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Topic(ctx, field.Selections, &res)
}

var updateLinkTopicsPayloadImplementors = []string{"UpdateLinkTopicsPayload"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UpdateLinkTopicsPayload(ctx context.Context, sel ast.SelectionSet, obj *UpdateLinkTopicsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, updateLinkTopicsPayloadImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateLinkTopicsPayload")
		case "link":
			out.Values[i] = ec._UpdateLinkTopicsPayload_link(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _UpdateLinkTopicsPayload_link(ctx context.Context, field graphql.CollectedField, obj *UpdateLinkTopicsPayload) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UpdateLinkTopicsPayload",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Link, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(LinkValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Link(ctx, field.Selections, &res)
}

var updateTopicParentTopicsPayloadImplementors = []string{"UpdateTopicParentTopicsPayload", "Alertable"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UpdateTopicParentTopicsPayload(ctx context.Context, sel ast.SelectionSet, obj *UpdateTopicParentTopicsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, updateTopicParentTopicsPayloadImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateTopicParentTopicsPayload")
		case "alerts":
			out.Values[i] = ec._UpdateTopicParentTopicsPayload_alerts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "topic":
			out.Values[i] = ec._UpdateTopicParentTopicsPayload_topic(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _UpdateTopicParentTopicsPayload_alerts(ctx context.Context, field graphql.CollectedField, obj *UpdateTopicParentTopicsPayload) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UpdateTopicParentTopicsPayload",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alerts, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Alert)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Alert(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _UpdateTopicParentTopicsPayload_topic(ctx context.Context, field graphql.CollectedField, obj *UpdateTopicParentTopicsPayload) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UpdateTopicParentTopicsPayload",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Topic, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TopicValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Topic(ctx, field.Selections, &res)
}

var updateTopicPayloadImplementors = []string{"UpdateTopicPayload"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UpdateTopicPayload(ctx context.Context, sel ast.SelectionSet, obj *UpdateTopicPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, updateTopicPayloadImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateTopicPayload")
		case "alerts":
			out.Values[i] = ec._UpdateTopicPayload_alerts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "topic":
			out.Values[i] = ec._UpdateTopicPayload_topic(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _UpdateTopicPayload_alerts(ctx context.Context, field graphql.CollectedField, obj *UpdateTopicPayload) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UpdateTopicPayload",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alerts, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Alert)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Alert(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _UpdateTopicPayload_topic(ctx context.Context, field graphql.CollectedField, obj *UpdateTopicPayload) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UpdateTopicPayload",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Topic, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TopicValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Topic(ctx, field.Selections, &res)
}

var upsertLinkPayloadImplementors = []string{"UpsertLinkPayload", "Alertable"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UpsertLinkPayload(ctx context.Context, sel ast.SelectionSet, obj *UpsertLinkPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, upsertLinkPayloadImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpsertLinkPayload")
		case "alerts":
			out.Values[i] = ec._UpsertLinkPayload_alerts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "linkEdge":
			out.Values[i] = ec._UpsertLinkPayload_linkEdge(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _UpsertLinkPayload_alerts(ctx context.Context, field graphql.CollectedField, obj *UpsertLinkPayload) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UpsertLinkPayload",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alerts, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Alert)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Alert(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _UpsertLinkPayload_linkEdge(ctx context.Context, field graphql.CollectedField, obj *UpsertLinkPayload) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UpsertLinkPayload",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LinkEdge, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*LinkEdge)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._LinkEdge(ctx, field.Selections, res)
}

var upsertTopicPayloadImplementors = []string{"UpsertTopicPayload", "Alertable"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UpsertTopicPayload(ctx context.Context, sel ast.SelectionSet, obj *UpsertTopicPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, upsertTopicPayloadImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpsertTopicPayload")
		case "alerts":
			out.Values[i] = ec._UpsertTopicPayload_alerts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "topicEdge":
			out.Values[i] = ec._UpsertTopicPayload_topicEdge(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _UpsertTopicPayload_alerts(ctx context.Context, field graphql.CollectedField, obj *UpsertTopicPayload) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UpsertTopicPayload",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alerts, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Alert)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Alert(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _UpsertTopicPayload_topicEdge(ctx context.Context, field graphql.CollectedField, obj *UpsertTopicPayload) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UpsertTopicPayload",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicEdge, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TopicEdge)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._TopicEdge(ctx, field.Selections, res)
}

var userImplementors = []string{"User"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *User) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, userImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "avatarUrl":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_avatarUrl(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "createdAt":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_createdAt(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "defaultRepository":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_defaultRepository(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
		case "isGuest":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_isGuest(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "name":
			out.Values[i] = ec._User_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "primaryEmail":
			out.Values[i] = ec._User_primaryEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "repositories":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_repositories(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "selectedRepository":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_selectedRepository(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "updatedAt":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_updatedAt(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _User_avatarUrl(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().AvatarURL(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _User_createdAt(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().CreatedAt(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _User_defaultRepository(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().DefaultRepository(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Repository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Repository(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _User_isGuest(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().IsGuest(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _User_primaryEmail(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrimaryEmail, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _User_repositories(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_User_repositories_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Repositories(rctx, obj, args["first"].(*int), args["after"].(*string), args["last"].(*int), args["before"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(RepositoryConnection)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._RepositoryConnection(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _User_selectedRepository(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().SelectedRepository(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Repository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Repository(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _User_updatedAt(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().UpdatedAt(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var viewImplementors = []string{"View"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _View(ctx context.Context, sel ast.SelectionSet, obj *View) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, viewImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("View")
		case "link":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._View_link(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "links":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._View_links(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "currentRepository":
			out.Values[i] = ec._View_currentRepository(ctx, field, obj)
		case "topic":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._View_topic(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "topics":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._View_topics(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _View_link(ctx context.Context, field graphql.CollectedField, obj *View) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_View_link_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "View",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.View().Link(rctx, obj, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*LinkValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Link(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _View_links(ctx context.Context, field graphql.CollectedField, obj *View) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_View_links_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "View",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.View().Links(rctx, obj, args["searchString"].(*string), args["first"].(*int), args["after"].(*string), args["last"].(*int), args["before"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(LinkConnection)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._LinkConnection(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _View_currentRepository(ctx context.Context, field graphql.CollectedField, obj *View) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "View",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentRepository, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Repository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Repository(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _View_topic(ctx context.Context, field graphql.CollectedField, obj *View) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_View_topic_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "View",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.View().Topic(rctx, obj, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TopicValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Topic(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _View_topics(ctx context.Context, field graphql.CollectedField, obj *View) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_View_topics_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "View",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.View().Topics(rctx, obj, args["searchString"].(*string), args["first"].(*int), args["after"].(*string), args["last"].(*int), args["before"].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TopicConnection)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._TopicConnection(ctx, field.Selections, &res)
}

var __DirectiveImplementors = []string{"__Directive"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __DirectiveImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var __EnumValueImplementors = []string{"__EnumValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __EnumValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __FieldImplementors = []string{"__Field"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __FieldImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __InputValueImplementors = []string{"__InputValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __InputValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __SchemaImplementors = []string{"__Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __SchemaImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Directive(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var __TypeImplementors = []string{"__Type"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __TypeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field___Type_fields_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Field(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field___Type_enumValues_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___EnumValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) _Alertable(ctx context.Context, sel ast.SelectionSet, obj *Alertable) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case UpdateTopicParentTopicsPayload:
		return ec._UpdateTopicParentTopicsPayload(ctx, sel, &obj)
	case *UpdateTopicParentTopicsPayload:
		return ec._UpdateTopicParentTopicsPayload(ctx, sel, obj)
	case UpsertLinkPayload:
		return ec._UpsertLinkPayload(ctx, sel, &obj)
	case *UpsertLinkPayload:
		return ec._UpsertLinkPayload(ctx, sel, obj)
	case UpsertTopicPayload:
		return ec._UpsertTopicPayload(ctx, sel, &obj)
	case *UpsertTopicPayload:
		return ec._UpsertTopicPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Namespaceable(ctx context.Context, sel ast.SelectionSet, obj *Namespaceable) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case LinkValue:
		return ec._Link(ctx, sel, &obj)
	case *LinkValue:
		return ec._Link(ctx, sel, obj)
	case TopicValue:
		return ec._Topic(ctx, sel, &obj)
	case *TopicValue:
		return ec._Topic(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ResourceIdentifiable(ctx context.Context, sel ast.SelectionSet, obj *ResourceIdentifiable) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case LinkValue:
		return ec._Link(ctx, sel, &obj)
	case *LinkValue:
		return ec._Link(ctx, sel, obj)
	case Organization:
		return ec._Organization(ctx, sel, &obj)
	case *Organization:
		return ec._Organization(ctx, sel, obj)
	case TopicValue:
		return ec._Topic(ctx, sel, &obj)
	case *TopicValue:
		return ec._Topic(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SearchResultItem(ctx context.Context, sel ast.SelectionSet, obj *SearchResultItem) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case TopicValue:
		return ec._Topic(ctx, sel, &obj)
	case *TopicValue:
		return ec._Topic(ctx, sel, obj)
	case LinkValue:
		return ec._Link(ctx, sel, &obj)
	case *LinkValue:
		return ec._Link(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func UnmarshalSelectRepositoryInput(v interface{}) (SelectRepositoryInput, error) {
	var it SelectRepositoryInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "clientMutationId":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.ClientMutationID = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "repositoryId":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalID(v)
				it.RepositoryID = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalUpdateLinkTopicsInput(v interface{}) (UpdateLinkTopicsInput, error) {
	var it UpdateLinkTopicsInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "clientMutationId":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.ClientMutationID = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "linkId":
			var err error
			it.LinkID, err = graphql.UnmarshalID(v)
			if err != nil {
				return it, err
			}
		case "parentTopicIds":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.ParentTopicIds = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.ParentTopicIds[idx1], err = graphql.UnmarshalID(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalUpdateTopicInput(v interface{}) (UpdateTopicInput, error) {
	var it UpdateTopicInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "clientMutationId":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.ClientMutationID = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "description":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Description = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "id":
			var err error
			it.ID, err = graphql.UnmarshalID(v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "topicIds":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.TopicIds = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.TopicIds[idx1], err = graphql.UnmarshalID(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalUpdateTopicParentTopicsInput(v interface{}) (UpdateTopicParentTopicsInput, error) {
	var it UpdateTopicParentTopicsInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "clientMutationId":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.ClientMutationID = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "topicId":
			var err error
			it.TopicID, err = graphql.UnmarshalID(v)
			if err != nil {
				return it, err
			}
		case "parentTopicIds":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.ParentTopicIds = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.ParentTopicIds[idx1], err = graphql.UnmarshalID(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalUpsertLinkInput(v interface{}) (UpsertLinkInput, error) {
	var it UpsertLinkInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "addParentTopicIds":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.AddParentTopicIds = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.AddParentTopicIds[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "clientMutationId":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.ClientMutationID = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "organizationLogin":
			var err error
			it.OrganizationLogin, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "repositoryName":
			var err error
			it.RepositoryName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "title":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Title = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "url":
			var err error
			it.URL, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalUpsertTopicInput(v interface{}) (UpsertTopicInput, error) {
	var it UpsertTopicInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "clientMutationId":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.ClientMutationID = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "description":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Description = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "organizationLogin":
			var err error
			it.OrganizationLogin, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "repositoryName":
			var err error
			it.RepositoryName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "topicIds":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.TopicIds = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.TopicIds[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) FieldMiddleware(ctx context.Context, obj interface{}, next graphql.Resolver) (ret interface{}) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	res, err := ec.ResolverMiddleware(ctx, next)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return res
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "schema.graphql", Input: `type Alert {
  text: String!
  type: AlertType!
  id: String!
}

interface Alertable {
  alerts: [Alert!]!
}

enum AlertType {
  SUCCESS
  WARN
  ERROR
}

scalar Color

scalar DateTime

type Link implements ResourceIdentifiable & Namespaceable {
  availableParentTopics(
    first: Int,
    after: String,
    last: Int,
    before: String
  ): TopicConnection!
  createdAt: DateTime!
  id: ID!
  loading: Boolean!
  newlyAdded: Boolean!
  organization: Organization!
  parentTopics(
    first: Int,
    after: String,
    last: Int,
    before: String
  ): TopicConnection!
  repository: Repository!
  resourcePath: String!
  sha1: String!
  title: String!
  updatedAt: DateTime!
  url: String!
}

type LinkEdge {
  cursor: String!
  node: Link!
}

type LinkConnection {
  edges: [LinkEdge]
  pageInfo: PageInfo!
}

type Mutation {
  selectRepository(input: SelectRepositoryInput!): SelectRepositoryPayload
  updateLinkTopics(input: UpdateLinkTopicsInput!): UpdateLinkTopicsPayload
  updateTopic(input: UpdateTopicInput!): UpdateTopicPayload
  updateTopicParentTopics(input: UpdateTopicParentTopicsInput!): UpdateTopicParentTopicsPayload
  upsertLink(input: UpsertLinkInput!): UpsertLinkPayload
  upsertTopic(input: UpsertTopicInput!): UpsertTopicPayload
}

interface Namespaceable {
  organization: Organization!
}

type Organization implements ResourceIdentifiable {
  createdAt: DateTime!
  defaultRepository: Repository!
  id: ID
  login: String!
  name: String!
  public: Boolean!
  resourcePath: String!
  updatedAt: DateTime!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  # Workaround for Relay Modern weirdness
  alerts: [Alert!]
  defaultOrganization: Organization!
  fakeError: String
  viewer: User!
  view(
    currentOrganizationLogin: String!,
    currentRepositoryName: String,
    repositoryIds: [ID!],
    viewerId: ID
  ): View!
}

type Repository {
  displayColor: Color!
  displayName: String!
  fullName: String!
  id: ID
  isPrivate: Boolean!
  name: String!
  organization: Organization!
  owner: User!
  rootTopic: Topic!
}

type RepositoryConnection {
  edges: [RepositoryEdge]
}

type RepositoryEdge {
  cursor: String!
  node: Repository!
  isSelected: Boolean!
}

interface ResourceIdentifiable {
  resourcePath: String!
}

union SearchResultItem = Topic | Link

type SearchResultItemEdge {
  node: SearchResultItem
}

type SearchResultItemConnection {
  edges: [SearchResultItemEdge]
}

input SelectRepositoryInput {
  clientMutationId: String
  repositoryId: ID
}

type SelectRepositoryPayload {
  repository: Repository
  viewer: User!
}

type Topic implements ResourceIdentifiable & Namespaceable {
  availableParentTopics(
    first: Int,
    after: String,
    last: Int,
    before: String
  ): TopicConnection!
  childTopics(
    searchString: String,
    first: Int,
    after: String,
    last: Int,
    before: String
  ): TopicConnection!
  createdAt: DateTime!
  description: String
  id: ID!
  links(
    searchString: String,
    first: Int,
    after: String,
    last: Int,
    before: String
  ): LinkConnection!
  loading: Boolean!
  name: String!
  newlyAdded: Boolean!
  organization: Organization!
  parentTopics(
    first: Int,
    after: String,
    last: Int,
    before: String
  ): TopicConnection!
  repository: Repository!
  resourcePath: String!
  search(
    searchString: String!,
    first: Int,
    after: String,
    last: Int,
    before: String
  ): SearchResultItemConnection!
  updatedAt: DateTime!
}

type TopicEdge {
  cursor: String!
  node: Topic!
}

type TopicConnection {
  edges: [TopicEdge]
  pageInfo: PageInfo!
}

type User {
  avatarUrl: String!
  createdAt: DateTime!
  defaultRepository: Repository
  id: ID
  isGuest: Boolean!
  name: String!
  primaryEmail: String!
  repositories(
    first: Int,
    after: String,
    last: Int,
    before: String
  ): RepositoryConnection!
  selectedRepository: Repository
  updatedAt: DateTime!
}

input UpdateTopicInput {
  clientMutationId: String
  description: String
  id: ID!
  name: String!
  topicIds: [ID!]
}

type UpdateTopicPayload {
  alerts: [Alert!]!
  topic: Topic!
}

input UpdateLinkTopicsInput {
  clientMutationId: String
  linkId: ID!
  parentTopicIds: [ID!]
}

type UpdateLinkTopicsPayload {
  link: Link!
}

input UpdateTopicParentTopicsInput {
  clientMutationId: String
  topicId: ID!
  parentTopicIds: [ID!]
}

type UpdateTopicParentTopicsPayload implements Alertable {
  alerts: [Alert!]!
  topic: Topic!
}

input UpsertLinkInput {
  addParentTopicIds: [String!]
  clientMutationId: String
  organizationLogin: String!
  repositoryName: String!
  title: String
  url: String!
}

type UpsertLinkPayload implements Alertable {
  alerts: [Alert!]!
  linkEdge: LinkEdge
}

input UpsertTopicInput {
  clientMutationId: String
  description: String
  name: String!
  organizationLogin: String!
  repositoryName: String!
  topicIds: [String!]
}

type UpsertTopicPayload implements Alertable {
  alerts: [Alert!]!
  topicEdge: TopicEdge
}

type View {
  link(id: ID!): Link
  links(
    searchString: String,
    first: Int,
    after: String,
    last: Int,
    before: String
  ): LinkConnection!
  currentRepository: Repository
  topic(id: ID!): Topic
  topics(
    searchString: String,
    first: Int,
    after: String,
    last: Int,
    before: String
  ): TopicConnection!
}
`},
)
